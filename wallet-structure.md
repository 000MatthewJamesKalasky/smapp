# Spacemesh app wallet structure
## Wallet name
Wallet name is ```my_wallet_<serial number>_<creation timestamp>.json```
- Serial number - integer starting at 0, number of the current wallet created in the app after it's last installation. Can be 0 constantly.
- Creation timestamp - date in the format of ISO date string with all `:` replaced with `-`.

Example: `my_wallet_0_2020-05-26T09-53-06.105Z`

## Wallet structure
```
{
  "meta": {
    "displayName": <string>,
    "created": <string>,
    "netId": <integer>,
    "meta": { "salt": "Spacemesh blockmesh" }
  },
  "crypto": {
    "cipher": "AES-128-CTR",
    "cipherText": <string>
  },
  "contacts": <array of Contact objects>
}
```
- `displayName` - wallet name, up to 50 chars.
- `created` - creation timestamp - same as in wallet file name.
- `netId` - will be used later to match wallet file to network, current value is constant `0`.
- `cipher` - indicator for the library used to encrypt/decrypt secret part of the wallet
- `cipherText` - encrypted part of the wallet. A decrypted object has the following structure:
    ```
        {
            mnemonic: <string>,
            accounts: [
                {
                    displayName: <string>,
                    created: <string>,
                    path: <string>,
                    publicKey: <string>,
                    secretKey: <string>
                }
            ]
        }
  ```
  - `mnemonic` - 12 words concatenated in single string with single space between each word. See `Mnemonic and secret/public keys` section.
  - `accounts` - array of account objects. Each object consists of:
    1. `displayName` - account name up to 50 chars.
    2. `created` - creation timestamp in the same format as in file name and wallet creation timestamp.
    3. `path` - string of the form `0/0/<account number>`, where `account number` is integer representing serial number of account created in this wallet. Not in use right now.
    4. `publicKey` - hex string of public key byte array. See `Mnemonic and secret/public keys` section.
    5. `secretKey` - hex string of secret key. See `Mnemonic and secret/public keys` section.
  - `contacts` - array of Contact objects: 
    1. `address` - 40 hex chars string representing contact's address (public key - last 40 chars of hex string representation of byte array).
    2. `nickname` - string up to 50 characters.
    
## Mnemonic and secret/public keys
Library used for creating mnemonic [bip39](https://github.com/bitcoinjs/bip39)
Library used for creating/deriving new public/secret key pair [ed25519](https://github.com/spacemeshos/ed25519)
- mnemonic is generated by calling `bip39.generateMnemonic`. Result is 12 words string separated by white space.
- secret/public key pair generation:
    - call `bip39.mnemonicToSeedSync` with generated mnemonic to generate seed.
    - use seed to call `ed25519.GenerateKey` to get secret and public keys as byte arrays. Add those to newly created account as hex strings.
- to derive new secret/public key pair call `ed25519.NewDerivedKeyFromSeed` with params:
    1. `seed` - from calling `bip39.mnemonicToSeedSync`
    2. `index` - account's serial number.
    3. `salt` - string "Spacemesh blockmesh" as byte array
- to validate mnemonic call `bip39.validateMnemonic`


## Signing and encoding outgoing transaction
Library used for signing outgoing transaction [ed25519](https://github.com/spacemeshos/ed25519)
Library used for encoding transaction [js-xdr](https://github.com/stellar/js-xdr)

- Translate secret key to bytes array.
- Create xdr types by calling:
```
xdr.config((xdr1) => {
 xdr1.struct('InnerSerializableSignedTransaction', [
   ['AccountNonce', xdr1.uhyper()],
   ['Recipient', xdr1.opaque(20)],
   ['GasLimit', xdr1.uhyper()],
   ['Price', xdr1.uhyper()],
   ['Amount', xdr1.uhyper()]
 ]);
 xdr1.struct('SerializableSignedTransaction', [
   ['InnerSerializableSignedTransaction', xdr1.lookup('InnerSerializableSignedTransaction')],
   ['Signature', xdr1.opaque(64)]
 ]);
});
```
- Create `message` by calling:
```
new types.InnerSerializableSignedTransaction({
  AccountNonce: xdr.UnsignedHyper.fromString(<accountNonce>),
  Recipient: fromHexString(<receiver>),
  GasLimit: xdr.UnsignedHyper.fromString(<limit>),
  Price: xdr.UnsignedHyper.fromString(<price>),
  Amount: xdr.UnsignedHyper.fromString(<amount>)
});
```

with following parameters:
1. `accountNonce` - integer acquired from node before sending transaction.
2. `receiver` - 40 hex chars string (last 20 bytes of bytes array of receiver public key).
3. `limit` - string, currently fixed `5`.
4. `price` - fee + amount to send string.
5. `amount` - string - amount to be send.

- Translate the `message` to byte array by calling ```message.toXDR()```.
- Sign `message` by calling ```ed25519.Sign2``` with `secretKey` and `message` as parameters.
- Create transaction using received `signature` and `message`:
```
new types.SerializableSignedTransaction({
  InnerSerializableSignedTransaction: message,
  Signature: signature
})
```
- Serialize transaction as xdr by calling ```transaction.toXDR()```.
- Send transaction to node.
    
    
    
---
## Creating encryption/decryption key
User types in a password - at least 8 unicode characters.
By utilising this library [pbkdf2](https://github.com/crypto-browserify/pbkdf2) and it's method with following parameters:

```pbkdf2.pbkdf2Sync(password, "Spacemesh blockmesh", 1000000, 32, "sha512")```

the encryption key is created. This key is used to encrypt and decrypt secret part of wallet file.

## Encryption and decryption
The encryption is done by this library [aes-js](https://github.com/ricmoo/aes-js) in the following way:
### Encryption
- calling ```aes.utils.utf8.toBytes``` on stringified data to be encrypted gives us byte array representation
- calling ```aes.ModeOfOperation.ctr(key, new aes.Counter(5))``` where ```key ``` is the encryption key we created before
- calling ```aes.encrypt``` with byte array from step 1 as function parameter
- calling ```aes.utils.hex.fromBytes``` on encryption result to get hex string representation of bytes array to be saved in wallet file
### Decryption
- calling ```aes.ModeOfOperation.ctr(key, new aes.Counter(5))``` where ```key ``` is the encryption key we created before
- calling ```aes.utils.hex.toBytes``` on encrypted string to get bytes array representation of encrypted data
- calling ```aes.decrypt``` decrypt the bytes array
- calling ```aes.utils.utf8.fromBytes``` get stringified representation of decrypted wallet data


